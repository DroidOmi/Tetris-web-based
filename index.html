<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Blocks Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .game-cell {
            width: 24px;
            height: 24px;
            border: 1px solid #d1d5db;
            transition: all 0.1s ease;
        }
        
        .filled {
            border: 2px solid #1f2937;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        
        @keyframes rowClear {
            0% { background-color: #fbbf24; transform: scale(1); }
            50% { background-color: #f59e0b; transform: scale(1.1); }
            100% { background-color: transparent; transform: scale(1); }
        }
        
        .row-clear {
            animation: rowClear 0.6s ease-in-out;
        }
        
        @keyframes piecePlace {
            from { transform: scale(1.1); }
            to { transform: scale(1); }
        }
        
        .piece-place {
            animation: piecePlace 0.15s ease-out;
        }
        
        .speed-indicator {
            transition: all 0.3s ease;
        }
        
        /* Custom button styles */
        .control-btn {
            background: linear-gradient(145deg, #f3f4f6, #e5e7eb);
            border: 2px solid #d1d5db;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-btn:active {
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.1);
            transform: translateY(1px);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-100 to-gray-200 min-h-screen flex items-center justify-center p-4 font-sans">
    <div class="flex flex-col xl:flex-row gap-6 items-start max-w-7xl">
        <!-- Main Game Area -->
        <div class="bg-white rounded-2xl shadow-xl p-6 border border-gray-200">
            <div class="text-center mb-6">
                <h1 class="text-4xl font-bold text-gray-800 mb-2">Falling Blocks</h1>
                <p class="text-gray-600">Stack blocks and clear rows to score points</p>
            </div>
            
            <!-- Game Grid -->
            <div class="relative">
                <div id="gameGrid" class="grid grid-cols-10 gap-0 bg-gray-50 p-3 rounded-xl border-2 border-gray-300 mx-auto" style="grid-template-rows: repeat(20, 1fr); width: fit-content;">
                    <!-- Grid cells generated by JavaScript -->
                </div>
                
                <!-- Game Over Overlay -->
                <div id="gameOverlay" class="absolute inset-0 bg-black bg-opacity-50 rounded-xl flex items-center justify-center hidden">
                    <div class="bg-white p-6 rounded-lg text-center">
                        <h3 class="text-2xl font-bold text-gray-800 mb-2">Game Complete!</h3>
                        <p id="finalScore" class="text-gray-600 mb-4">Final Score: 0</p>
                        <button onclick="resetGame()" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold">
                            Play Again
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Game Controls -->
            <div class="mt-6 space-y-4">
                <div class="flex justify-center gap-3">
                    <button id="startBtn" onclick="startGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-colors">
                        Start Game
                    </button>
                    <button id="pauseBtn" onclick="togglePause()" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg transition-colors" disabled>
                        Pause
                    </button>
                    <button onclick="resetGame()" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg transition-colors">
                        Reset
                    </button>
                </div>
                
                <!-- Speed Control -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <label class="block text-sm font-semibold text-gray-700 mb-2">Drop Speed</label>
                    <div class="flex items-center gap-3">
                        <span class="text-sm text-gray-600">Slow</span>
                        <input type="range" id="speedSlider" min="1" max="10" value="5" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <span class="text-sm text-gray-600">Fast</span>
                    </div>
                    <div class="text-center mt-2">
                        <span id="speedDisplay" class="text-sm font-medium text-blue-600">Speed: 5</span>
                    </div>
                </div>
                
                <!-- Mobile Touch Controls -->
                <div class="grid grid-cols-4 gap-2 max-w-sm mx-auto md:hidden">
                    <button onclick="moveLeft()" class="control-btn text-gray-700 font-bold py-3 px-4 rounded-lg">
                        ←
                    </button>
                    <button onclick="rotatePiece()" class="control-btn text-gray-700 font-bold py-3 px-4 rounded-lg">
                        ↻
                    </button>
                    <button onclick="moveRight()" class="control-btn text-gray-700 font-bold py-3 px-4 rounded-lg">
                        →
                    </button>
                    <button onclick="dropFast()" class="control-btn text-gray-700 font-bold py-3 px-4 rounded-lg">
                        ↓
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Game Information Panel -->
        <div class="bg-white rounded-2xl shadow-xl p-6 border border-gray-200 min-w-72">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Game Info</h2>
            
            <!-- Statistics -->
            <div class="space-y-4 mb-6">
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                    <div class="text-sm text-blue-600 font-medium">Score</div>
                    <div id="scoreDisplay" class="text-3xl font-bold text-blue-800">0</div>
                </div>
                
                <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                    <div class="text-sm text-green-600 font-medium">Rows Cleared</div>
                    <div id="rowsDisplay" class="text-3xl font-bold text-green-800">0</div>
                </div>
                
                <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                    <div class="text-sm text-purple-600 font-medium">Level</div>
                    <div id="levelDisplay" class="text-3xl font-bold text-purple-800">1</div>
                </div>
            </div>
            
            <!-- Next Piece Preview -->
            <div class="mb-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Next Piece</h3>
                <div id="nextPreview" class="grid grid-cols-4 gap-1 bg-gray-50 p-4 rounded-lg border border-gray-200" style="grid-template-rows: repeat(4, 1fr); width: fit-content;">
                    <!-- Preview cells generated by JavaScript -->
                </div>
            </div>
            
            <!-- Game Instructions -->
            <div class="text-sm text-gray-600 space-y-2">
                <h3 class="font-semibold text-gray-800 mb-2">How to Play:</h3>
                <div class="space-y-1">
                    <div><strong>←/→:</strong> Move piece left/right</div>
                    <div><strong>↑:</strong> Rotate piece</div>
                    <div><strong>↓:</strong> Drop piece faster</div>
                    <div><strong>Space:</strong> Instant drop</div>
                </div>
                <div class="mt-3 p-3 bg-yellow-50 rounded border border-yellow-200">
                    <strong>Goal:</strong> Fill complete rows to clear them and score points!
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 20;
        const BASE_SPEED = 1000;
        
        // Game State Variables
        let gameBoard = [];
        let currentPiece = null;
        let nextPiece = null;
        let gameActive = false;
        let gamePaused = false;
        let playerScore = 0;
        let rowsCleared = 0;
        let currentLevel = 1;
        let dropInterval = null;
        let currentSpeed = 5;
        
        // Original Piece Definitions (completely custom shapes and colors)
        const PIECE_TYPES = [
            // Straight line piece
            {
                blocks: [[1,1,1,1]],
                color: '#dc2626'
            },
            // Square piece
            {
                blocks: [[1,1],[1,1]],
                color: '#ea580c'
            },
            // T-shaped piece
            {
                blocks: [[0,1,0],[1,1,1]],
                color: '#ca8a04'
            },
            // S-shaped piece
            {
                blocks: [[0,1,1],[1,1,0]],
                color: '#16a34a'
            },
            // Z-shaped piece
            {
                blocks: [[1,1,0],[0,1,1]],
                color: '#2563eb'
            },
            // L-shaped piece
            {
                blocks: [[1,0,0],[1,1,1]],
                color: '#7c3aed'
            },
            // Reverse L-shaped piece
            {
                blocks: [[0,0,1],[1,1,1]],
                color: '#c2410c'
            }
        ];
        
        // Initialize game board
        function initializeBoard() {
            gameBoard = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
            
            const gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = '';
            
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'game-cell';
                    cell.id = `cell-${row}-${col}`;
                    gridElement.appendChild(cell);
                }
            }
            
            // Initialize preview grid
            const previewElement = document.getElementById('nextPreview');
            previewElement.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'w-5 h-5 border border-gray-300 rounded-sm';
                cell.id = `preview-${i}`;
                previewElement.appendChild(cell);
            }
        }
        
        // Generate random piece
        function generatePiece() {
            const pieceType = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
            return {
                blocks: pieceType.blocks,
                color: pieceType.color,
                x: Math.floor(GRID_WIDTH / 2) - Math.floor(pieceType.blocks[0].length / 2),
                y: 0
            };
        }
        
        // Rotate piece 90 degrees clockwise
        function getRotatedPiece(piece) {
            const rotatedBlocks = piece.blocks[0].map((_, index) =>
                piece.blocks.map(row => row[index]).reverse()
            );
            return { ...piece, blocks: rotatedBlocks };
        }
        
        // Check if piece position is valid
        function isValidPosition(piece, offsetX = 0, offsetY = 0) {
            for (let row = 0; row < piece.blocks.length; row++) {
                for (let col = 0; col < piece.blocks[row].length; col++) {
                    if (piece.blocks[row][col]) {
                        const newX = piece.x + col + offsetX;
                        const newY = piece.y + row + offsetY;
                        
                        if (newX < 0 || newX >= GRID_WIDTH || newY >= GRID_HEIGHT) {
                            return false;
                        }
                        
                        if (newY >= 0 && gameBoard[newY][newX]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        // Lock piece to board
        function lockPiece(piece) {
            for (let row = 0; row < piece.blocks.length; row++) {
                for (let col = 0; col < piece.blocks[row].length; col++) {
                    if (piece.blocks[row][col]) {
                        const boardY = piece.y + row;
                        const boardX = piece.x + col;
                        if (boardY >= 0) {
                            gameBoard[boardY][boardX] = piece.color;
                        }
                    }
                }
            }
        }
        
        // Clear completed rows
        function clearCompletedRows() {
            let clearedCount = 0;
            
            for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
                if (gameBoard[row].every(cell => cell !== null)) {
                    // Animate row clearing
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        const cell = document.getElementById(`cell-${row}-${col}`);
                        cell.classList.add('row-clear');
                    }
                    
                    setTimeout(() => {
                        gameBoard.splice(row, 1);
                        gameBoard.unshift(Array(GRID_WIDTH).fill(null));
                        clearedCount++;
                        row++; // Check same row again
                        updateDisplay();
                    }, 300);
                }
            }
            
            if (clearedCount > 0) {
                rowsCleared += clearedCount;
                playerScore += clearedCount * 100 * currentLevel;
                currentLevel = Math.floor(rowsCleared / 10) + 1;
                updateGameInfo();
            }
        }
        
        // Update visual display
        function updateDisplay() {
            // Clear all cells
            for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    if (gameBoard[row][col]) {
                        cell.style.backgroundColor = gameBoard[row][col];
                        cell.classList.add('filled');
                    } else {
                        cell.style.backgroundColor = '';
                        cell.classList.remove('filled');
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                for (let row = 0; row < currentPiece.blocks.length; row++) {
                    for (let col = 0; col < currentPiece.blocks[row].length; col++) {
                        if (currentPiece.blocks[row][col]) {
                            const boardY = currentPiece.y + row;
                            const boardX = currentPiece.x + col;
                            if (boardY >= 0 && boardY < GRID_HEIGHT && boardX >= 0 && boardX < GRID_WIDTH) {
                                const cell = document.getElementById(`cell-${boardY}-${boardX}`);
                                cell.style.backgroundColor = currentPiece.color;
                                cell.classList.add('filled');
                            }
                        }
                    }
                }
            }
            
            // Update next piece preview
            for (let i = 0; i < 16; i++) {
                const cell = document.getElementById(`preview-${i}`);
                cell.style.backgroundColor = '';
            }
            
            if (nextPiece) {
                for (let row = 0; row < nextPiece.blocks.length; row++) {
                    for (let col = 0; col < nextPiece.blocks[row].length; col++) {
                        if (nextPiece.blocks[row][col]) {
                            const index = (row + 1) * 4 + (col + 1);
                            if (index < 16) {
                                const cell = document.getElementById(`preview-${index}`);
                                cell.style.backgroundColor = nextPiece.color;
                            }
                        }
                    }
                }
            }
        }
        
        // Update game information display
        function updateGameInfo() {
            document.getElementById('scoreDisplay').textContent = playerScore;
            document.getElementById('rowsDisplay').textContent = rowsCleared;
            document.getElementById('levelDisplay').textContent = currentLevel;
        }
        
        // Main game loop
        function gameLoop() {
            if (!gameActive || gamePaused) return;
            
            if (isValidPosition(currentPiece, 0, 1)) {
                currentPiece.y++;
            } else {
                lockPiece(currentPiece);
                clearCompletedRows();
                currentPiece = nextPiece;
                nextPiece = generatePiece();
                
                if (!isValidPosition(currentPiece)) {
                    endGame();
                    return;
                }
            }
            
            updateDisplay();
            const speed = BASE_SPEED - (currentSpeed - 1) * 90;
            dropInterval = setTimeout(gameLoop, Math.max(50, speed));
        }
        
        // Start new game
        function startGame() {
            if (gameActive) return;
            
            gameActive = true;
            gamePaused = false;
            playerScore = 0;
            rowsCleared = 0;
            currentLevel = 1;
            
            initializeBoard();
            currentPiece = generatePiece();
            nextPiece = generatePiece();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('gameOverlay').classList.add('hidden');
            
            updateGameInfo();
            updateDisplay();
            gameLoop();
        }
        
        // Toggle pause
        function togglePause() {
            if (!gameActive) return;
            
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').textContent = gamePaused ? 'Resume' : 'Pause';
            
            if (!gamePaused) {
                gameLoop();
            } else if (dropInterval) {
                clearTimeout(dropInterval);
            }
        }
        
        // Reset game
        function resetGame() {
            gameActive = false;
            gamePaused = false;
            
            if (dropInterval) {
                clearTimeout(dropInterval);
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('gameOverlay').classList.add('hidden');
            
            playerScore = 0;
            rowsCleared = 0;
            currentLevel = 1;
            
            initializeBoard();
            updateGameInfo();
            updateDisplay();
        }
        
        // End game
        function endGame() {
            gameActive = false;
            document.getElementById('finalScore').textContent = `Final Score: ${playerScore}`;
            document.getElementById('gameOverlay').classList.remove('hidden');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        }
        
        // Movement functions
        function moveLeft() {
            if (!gameActive || gamePaused || !currentPiece) return;
            if (isValidPosition(currentPiece, -1, 0)) {
                currentPiece.x--;
                updateDisplay();
            }
        }
        
        function moveRight() {
            if (!gameActive || gamePaused || !currentPiece) return;
            if (isValidPosition(currentPiece, 1, 0)) {
                currentPiece.x++;
                updateDisplay();
            }
        }
        
        function rotatePiece() {
            if (!gameActive || gamePaused || !currentPiece) return;
            const rotated = getRotatedPiece(currentPiece);
            if (isValidPosition(rotated)) {
                currentPiece = rotated;
                updateDisplay();
            }
        }
        
        function dropFast() {
            if (!gameActive || gamePaused || !currentPiece) return;
            if (isValidPosition(currentPiece, 0, 1)) {
                currentPiece.y++;
                playerScore += 1;
                updateGameInfo();
                updateDisplay();
            }
        }
        
        function instantDrop() {
            if (!gameActive || gamePaused || !currentPiece) return;
            while (isValidPosition(currentPiece, 0, 1)) {
                currentPiece.y++;
                playerScore += 2;
            }
            updateGameInfo();
            updateDisplay();
        }
        
        // Speed control
        document.getElementById('speedSlider').addEventListener('input', function(e) {
            currentSpeed = parseInt(e.target.value);
            document.getElementById('speedDisplay').textContent = `Speed: ${currentSpeed}`;
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    moveLeft();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    moveRight();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    rotatePiece();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    dropFast();
                    break;
                case ' ':
                    e.preventDefault();
                    instantDrop();
                    break;
            }
        });
        
        // Initialize game
        initializeBoard();
        updateGameInfo();
        updateDisplay();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96c0c8adb2413f5b',t:'MTc1NDY3NDY3MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
